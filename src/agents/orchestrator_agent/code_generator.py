"""Dynamic Python Script Generation for Task Execution."""

import logging
from typing import Dict, Any, List, Set
from pathlib import Path

logger = logging.getLogger(__name__)


class CodeGenerator:
    """
    Generates executable Python scripts for task orchestration.
    """
    
    def __init__(self):
        """Initialize code generator."""
        logger.info("CodeGenerator initialized")
    
    def generate_script(
        self,
        mapped_tasks: List[Dict[str, Any]],
        execution_order: List[List[int]]
    ) -> str:
        """
        Generate async Python script to execute tasks.
        
        Args:
            mapped_tasks: List of tasks with agent mapping
            execution_order: List of parallel execution groups
            
        Returns:
            Python script as string
        """
        logger.info(f"Generating script for {len(mapped_tasks)} tasks")
        
        # Build dependency graph
        dependencies = self._build_dependency_graph(mapped_tasks)
        
        # Generate imports
        imports = self._generate_imports(mapped_tasks)
        
        # Generate task functions
        task_functions = self._generate_task_functions(mapped_tasks)
        
        # Generate main execution function
        main_function = self._generate_main_function(mapped_tasks, execution_order, dependencies)
        
        # Combine all parts
        script = f"""\"\"\"
Auto-generated orchestration script.
DO NOT EDIT - Generated by OrchestratorAgent
\"\"\"

import asyncio
import logging
from pathlib import Path
from typing import Dict, Any, Optional

{imports}

logger = logging.getLogger(__name__)


{task_functions}


{main_function}


if __name__ == "__main__":
    # Run the orchestration
    results = asyncio.run(main())
    
    # Print summary
    print("\\n" + "="*60)
    print("ORCHESTRATION COMPLETE")
    print("="*60)
    for i, result in enumerate(results, 1):
        status = "✓ SUCCESS" if result.get('status') == 'success' else "✗ FAILED"
        print(f"Task {{i}}: {{status}}")
        if result.get('error'):
            print(f"  Error: {{result['error']}}")
    print("="*60)
"""
        
        logger.info(f"Generated script with {len(task_functions.split('async def'))-1} task functions")
        return script
    
    def _generate_imports(self, mapped_tasks: List[Dict[str, Any]]) -> str:
        """Generate import statements."""
        imports = set()
        
        for task in mapped_tasks:
            agent_name = task.get('mapped_agent')
            if agent_name and task.get('mappable'):
                from .config import AGENT_CAPABILITIES
                config = AGENT_CAPABILITIES.get(agent_name, {})
                module = config.get('module', '')
                class_name = config.get('class', '')
                
                if module and class_name:
                    imports.add(f"from {module} import {class_name}")
        
        return '\n'.join(sorted(imports))
    
    def _generate_task_functions(self, mapped_tasks: List[Dict[str, Any]]) -> str:
        """Generate async task functions."""
        functions = []
        
        for task in mapped_tasks:
            if not task.get('mappable'):
                # Skip unmappable tasks
                continue
            
            task_id = task.get('id')
            agent_name = task.get('mapped_agent')
            params = task.get('agent_params', {})
            description = task.get('description', '')
            
            from .config import AGENT_CAPABILITIES
            config = AGENT_CAPABILITIES.get(agent_name, {})
            class_name = config.get('class', '')
            
            # Build parameter string
            param_str = self._build_param_string(params)
            
            function = f'''async def task_{task_id}() -> Dict[str, Any]:
    """
    Task {task_id}: {description}
    Agent: {agent_name}
    """
    logger.info(f"Starting task {task_id}: {description[:50]}...")
    try:
        agent = {class_name}()
        output_path = agent.run({param_str})
        
        logger.info(f"Task {task_id} completed: {{output_path}}")
        
        # Read output
        import json
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        return {{
            'status': 'success',
            'task_id': {task_id},
            'agent': '{agent_name}',
            'output_path': str(output_path),
            'data': output_data,
            'error': None
        }}
    except Exception as e:
        logger.error(f"Task {task_id} failed: {{e}}")
        return {{
            'status': 'failed',
            'task_id': {task_id},
            'agent': '{agent_name}',
            'output_path': None,
            'data': None,
            'error': str(e)
        }}
'''
            functions.append(function)
        
        return '\n\n'.join(functions)
    
    def _generate_main_function(
        self,
        mapped_tasks: List[Dict[str, Any]],
        execution_order: List[List[int]],
        dependencies: Dict[int, Set[int]]
    ) -> str:
        """Generate main async execution function."""
        
        # Filter to only mappable tasks
        mappable_task_ids = [t['id'] for t in mapped_tasks if t.get('mappable')]
        
        if not mappable_task_ids:
            return '''async def main() -> list:
    """Main orchestration function."""
    logger.warning("No mappable tasks found")
    return []
'''
        
        # Check if all tasks can run in parallel (no dependencies)
        has_dependencies = any(deps for deps in dependencies.values())
        
        if not has_dependencies and len(execution_order) == 1:
            # Simple parallel execution
            task_calls = ', '.join([f'task_{tid}()' for tid in mappable_task_ids])
            
            return f'''async def main() -> list:
    """Main orchestration function - parallel execution."""
    logger.info("Starting parallel execution of {len(mappable_task_ids)} tasks")
    
    results = await asyncio.gather(
        {task_calls}
    )
    
    logger.info("All tasks completed")
    return list(results)
'''
        else:
            # Sequential or mixed execution
            execution_code = []
            execution_code.append('    logger.info("Starting task execution")')
            execution_code.append('    all_results = []')
            execution_code.append('')
            
            for group_idx, group in enumerate(execution_order, 1):
                # Filter to only mappable tasks in this group
                group_tasks = [tid for tid in group if tid in mappable_task_ids]
                
                if not group_tasks:
                    continue
                
                if len(group_tasks) == 1:
                    # Single task
                    tid = group_tasks[0]
                    execution_code.append(f'    # Execute task {tid}')
                    execution_code.append(f'    result_{tid} = await task_{tid}()')
                    execution_code.append(f'    all_results.append(result_{tid})')
                else:
                    # Parallel group
                    task_calls = ', '.join([f'task_{tid}()' for tid in group_tasks])
                    execution_code.append(f'    # Execute parallel group {group_idx}')
                    execution_code.append(f'    group_results = await asyncio.gather({task_calls})')
                    execution_code.append(f'    all_results.extend(group_results)')
                
                execution_code.append('')
            
            execution_code.append('    logger.info("All tasks completed")')
            execution_code.append('    return all_results')
            
            function = f'''async def main() -> list:
    """Main orchestration function - sequential/mixed execution."""
{chr(10).join(execution_code)}
'''
            return function
    
    def _build_dependency_graph(self, mapped_tasks: List[Dict[str, Any]]) -> Dict[int, Set[int]]:
        """
        Build dependency graph from tasks.
        
        Args:
            mapped_tasks: List of tasks
            
        Returns:
            Dict mapping task_id to set of dependency task_ids
        """
        dependencies = {}
        
        for task in mapped_tasks:
            task_id = task.get('id')
            deps = task.get('dependencies', [])
            dependencies[task_id] = set(deps)
        
        return dependencies
    
    def _build_param_string(self, params: Dict[str, Any]) -> str:
        """
        Build parameter string for function call.
        
        Args:
            params: Parameters dictionary
            
        Returns:
            String like "param1=value1, param2=value2"
        """
        if not params:
            return ""
        
        param_parts = []
        for key, value in params.items():
            if value is None:
                param_parts.append(f"{key}=None")
            elif isinstance(value, str):
                # Escape quotes in string
                escaped = value.replace('"', '\\"')
                param_parts.append(f'{key}="{escaped}"')
            elif isinstance(value, dict):
                param_parts.append(f'{key}={value}')
            elif isinstance(value, list):
                param_parts.append(f'{key}={value}')
            else:
                param_parts.append(f'{key}={value}')
        
        return ', '.join(param_parts)

