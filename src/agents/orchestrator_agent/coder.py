"""Script Generation for Task Execution."""

import logging
from typing import Dict, Any, List
from pathlib import Path

from .config import AGENT_CAPABILITIES

logger = logging.getLogger(__name__)


class Coder:
    """
    Generates executable Python scripts for task execution.
    
    Extends CodeGenerator with:
    - Support for Planner 2 output format
    - DB writes for task outputs
    - File bus compatibility
    """
    
    def __init__(self):
        """Initialize coder."""
        logger.info("Coder initialized")
    
    def generate(
        self,
        path_plan: Dict[str, Any],
        run_id: str,
        db_path: Path
    ) -> str:
        """
        Generate execution script for a path.
        
        Args:
            path_plan: Path execution plan from Planner 2
            run_id: Orchestration run ID
            db_path: Path to workers database
            
        Returns:
            Python script as string
        """
        path_id = path_plan['path_id']
        execution_plan = path_plan['execution_plan']
        
        logger.info(f"Generating script for {path_id} with {len(execution_plan)} tasks")
        
        # Build script components
        imports = self._generate_imports(execution_plan)
        task_functions = self._generate_task_functions(execution_plan, run_id, db_path)
        main_function = self._generate_main_function(execution_plan, path_plan)
        
        # Combine into full script
        script = f'''"""
Auto-generated orchestration script for {path_id}.
DO NOT EDIT - Generated by OrchestratorAgent Coder
Run ID: {run_id}
"""

import asyncio
import json
import logging
import time
from pathlib import Path
from typing import Dict, Any, Optional

{imports}

from src.agents.orchestrator_agent.workers_db import WorkersDB

logger = logging.getLogger(__name__)

# Configuration
RUN_ID = "{run_id}"
DB_PATH = Path("{db_path}")


{task_functions}


{main_function}


if __name__ == "__main__":
    # Run the orchestration
    results = asyncio.run(main())
    
    # Print summary
    print("\\n" + "="*60)
    print(f"PATH: {path_id}")
    print("="*60)
    for i, result in enumerate(results, 1):
        status = "✓ SUCCESS" if result.get('status') == 'success' else "✗ FAILED"
        task_id = result.get('task_id', 'unknown')
        print(f"Task {{task_id}}: {{status}}")
        if result.get('error'):
            print(f"  Error: {{result['error']}}")
    print("="*60)
'''
        
        logger.info(f"Generated script for {path_id} ({len(execution_plan)} tasks)")
        return script
    
    def _generate_imports(
        self,
        execution_plan: List[Dict[str, Any]]
    ) -> str:
        """Generate import statements."""
        imports = set()
        
        for task_plan in execution_plan:
            agent_name = task_plan.get('agent')
            if agent_name:
                config = AGENT_CAPABILITIES.get(agent_name, {})
                module = config.get('module', '')
                class_name = config.get('class', '')
                
                if module and class_name:
                    imports.add(f"from {module} import {class_name}")
        
        return '\n'.join(sorted(imports))
    
    def _generate_task_functions(
        self,
        execution_plan: List[Dict[str, Any]],
        run_id: str,
        db_path: Path
    ) -> str:
        """Generate async task functions."""
        functions = []
        
        for task_plan in execution_plan:
            task_id = task_plan['task_id']
            agent_name = task_plan['agent']
            description = task_plan.get('description', '')
            agent_params = task_plan.get('agent_params', {})
            
            config = AGENT_CAPABILITIES.get(agent_name, {})
            class_name = config.get('class', '')
            
            # Build parameter string
            param_str = self._build_param_string(agent_params)
            
            function = f'''async def task_{task_id.replace("-", "_")}() -> Dict[str, Any]:
    """
    Task {task_id}: {description}
    Agent: {agent_name}
    """
    task_id = "{task_id}"
    agent_name = "{agent_name}"
    
    logger.info(f"Starting task {{task_id}}: {description[:50]}...")
    
    # Record task start in DB
    with WorkersDB(DB_PATH) as db:
        db.start_task(RUN_ID, task_id, agent_name)
    
    start_time = time.time()
    
    try:
        # Execute agent
        agent = {class_name}()
        output_path = agent.run({param_str})
        
        duration_ms = (time.time() - start_time) * 1000
        
        logger.info(f"Task {{task_id}} completed: {{output_path}}")
        
        # Read output from file bus
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        # Store in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='success',
                duration_ms=duration_ms,
                output_file_path=str(output_path)
            )
            db.store_task_output(
                RUN_ID,
                task_id,
                agent_name,
                output_data.get('data', []),
                output_data.get('metadata', {{}})
            )
        
        return {{
            'status': 'success',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': str(output_path),
            'data': output_data,
            'duration_ms': duration_ms,
            'error': None
        }}
        
    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        
        logger.error(f"Task {{task_id}} failed: {{e}}")
        
        # Record failure in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='failed',
                duration_ms=duration_ms,
                error=str(e)
            )
        
        return {{
            'status': 'failed',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': None,
            'data': None,
            'duration_ms': duration_ms,
            'error': str(e)
        }}
'''
            functions.append(function)
        
        return '\n\n'.join(functions)
    
    def _generate_main_function(
        self,
        execution_plan: List[Dict[str, Any]],
        path_plan: Dict[str, Any]
    ) -> str:
        """Generate main execution function."""
        if not execution_plan:
            return '''async def main() -> list:
    """Main orchestration function."""
    logger.warning("No tasks to execute")
    return []
'''
        
        # Check for dependencies
        has_dependencies = any(
            task_plan.get('dependencies')
            for task_plan in execution_plan
        )
        
        if not has_dependencies:
            # Simple parallel execution
            task_calls = ', '.join([
                f'task_{task_plan["task_id"].replace("-", "_")}()'
                for task_plan in execution_plan
            ])
            
            return f'''async def main() -> list:
    """Main orchestration function - parallel execution."""
    logger.info("Starting parallel execution of {len(execution_plan)} tasks")
    
    results = await asyncio.gather(
        {task_calls}
    )
    
    logger.info("All tasks completed")
    return list(results)
'''
        else:
            # Sequential or mixed execution
            return self._generate_dependency_aware_main(execution_plan, path_plan)
    
    def _generate_dependency_aware_main(
        self,
        execution_plan: List[Dict[str, Any]],
        path_plan: Dict[str, Any]
    ) -> str:
        """Generate main function with dependency handling."""
        execution_code = []
        execution_code.append('    logger.info("Starting dependency-aware execution")')
        execution_code.append('    all_results = []')
        execution_code.append('    task_outputs = {}  # Store outputs for dependency access')
        execution_code.append('')
        
        # Sort tasks by dependencies (topological sort)
        sorted_tasks = self._topological_sort(execution_plan)
        
        for task_plan in sorted_tasks:
            task_id = task_plan['task_id']
            task_func = f'task_{task_id.replace("-", "_")}'
            dependencies = task_plan.get('dependencies', [])
            
            if dependencies:
                # Add dependency check
                dep_checks = [f'"{dep}" in task_outputs' for dep in dependencies]
                dep_check_str = ' and '.join(dep_checks)
                
                execution_code.append(f'    # Task {task_id} (depends on: {", ".join(dependencies)})')
                execution_code.append(f'    if {dep_check_str}:')
                execution_code.append(f'        result = await {task_func}()')
                execution_code.append(f'        all_results.append(result)')
                execution_code.append(f'        task_outputs["{task_id}"] = result')
                execution_code.append(f'    else:')
                execution_code.append(f'        logger.error("Dependencies not met for task {task_id}")')
                execution_code.append(f'        all_results.append({{')
                execution_code.append(f'            "status": "failed",')
                execution_code.append(f'            "task_id": "{task_id}",')
                execution_code.append(f'            "error": "Dependencies not met"')
                execution_code.append(f'        }})')
            else:
                # No dependencies - execute immediately
                execution_code.append(f'    # Task {task_id} (no dependencies)')
                execution_code.append(f'    result = await {task_func}()')
                execution_code.append(f'    all_results.append(result)')
                execution_code.append(f'    task_outputs["{task_id}"] = result')
            
            execution_code.append('')
        
        execution_code.append('    logger.info("All tasks completed")')
        execution_code.append('    return all_results')
        
        function = f'''async def main() -> list:
    """Main orchestration function - dependency-aware execution."""
{chr(10).join(execution_code)}
'''
        return function
    
    def _topological_sort(
        self,
        execution_plan: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Sort tasks in topological order (dependencies first).
        
        Args:
            execution_plan: List of task plans
            
        Returns:
            Sorted list of task plans
        """
        from collections import deque, defaultdict
        
        # Build dependency graph
        graph = defaultdict(list)
        in_degree = {}
        task_map = {}
        
        for task_plan in execution_plan:
            task_id = task_plan['task_id']
            task_map[task_id] = task_plan
            in_degree[task_id] = 0
        
        for task_plan in execution_plan:
            task_id = task_plan['task_id']
            deps = task_plan.get('dependencies', [])
            
            in_degree[task_id] = len(deps)
            
            for dep in deps:
                if dep in task_map:  # Only count valid dependencies
                    graph[dep].append(task_id)
        
        # Topological sort using Kahn's algorithm
        queue = deque([tid for tid, degree in in_degree.items() if degree == 0])
        sorted_tasks = []
        
        while queue:
            task_id = queue.popleft()
            sorted_tasks.append(task_map[task_id])
            
            for neighbor in graph[task_id]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return sorted_tasks
    
    def _build_param_string(
        self,
        params: Dict[str, Any]
    ) -> str:
        """
        Build parameter string for function call.
        
        Args:
            params: Parameters dictionary
            
        Returns:
            String like "param1=value1, param2=value2"
        """
        if not params:
            return ""
        
        param_parts = []
        for key, value in params.items():
            if value is None:
                param_parts.append(f"{key}=None")
            elif isinstance(value, str):
                # Escape quotes in string
                escaped = value.replace('"', '\\"').replace("'", "\\'")
                param_parts.append(f'{key}="{escaped}"')
            elif isinstance(value, dict):
                param_parts.append(f'{key}={value}')
            elif isinstance(value, list):
                param_parts.append(f'{key}={value}')
            elif isinstance(value, bool):
                param_parts.append(f'{key}={value}')
            else:
                param_parts.append(f'{key}={value}')
        
        return ', '.join(param_parts)

