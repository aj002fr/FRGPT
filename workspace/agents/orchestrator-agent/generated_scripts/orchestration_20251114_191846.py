"""
Auto-generated orchestration script.
DO NOT EDIT - Generated by OrchestratorAgent
"""

import asyncio
import logging
from pathlib import Path
from typing import Dict, Any, Optional

from src.agents.market_data_agent.run import MarketDataAgent
from src.agents.reasoning_agent.run import ReasoningAgent

logger = logging.getLogger(__name__)


async def task_1() -> Dict[str, Any]:
    """
    Task 1: Retrieve historical closing data for ZN
    Agent: market_data_agent
    """
    logger.info(f"Starting task 1: Retrieve historical closing data for ZN...")
    try:
        agent = MarketDataAgent()
        output_path = agent.run(template="all_valid", params={}, columns=None, limit=None)
        
        logger.info(f"Task 1 completed: {output_path}")
        
        # Read output
        import json
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        return {
            'status': 'success',
            'task_id': 1,
            'agent': 'market_data_agent',
            'output_path': str(output_path),
            'data': output_data,
            'error': None
        }
    except Exception as e:
        logger.error(f"Task 1 failed: {e}")
        return {
            'status': 'failed',
            'task_id': 1,
            'agent': 'market_data_agent',
            'output_path': None,
            'data': None,
            'error': str(e)
        }


async def task_2() -> Dict[str, Any]:
    """
    Task 2: Identify all instances where ZN closed in the range of 112.5 to 112.9
    Agent: reasoning_agent
    """
    logger.info(f"Starting task 2: Identify all instances where ZN closed in the rang...")
    try:
        agent = ReasoningAgent()
        output_path = agent.run(query="identify all instances where zn closed in the range of 112.5 to 112.9", session_id=None)
        
        logger.info(f"Task 2 completed: {output_path}")
        
        # Read output
        import json
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        return {
            'status': 'success',
            'task_id': 2,
            'agent': 'reasoning_agent',
            'output_path': str(output_path),
            'data': output_data,
            'error': None
        }
    except Exception as e:
        logger.error(f"Task 2 failed: {e}")
        return {
            'status': 'failed',
            'task_id': 2,
            'agent': 'reasoning_agent',
            'output_path': None,
            'data': None,
            'error': str(e)
        }


async def task_3() -> Dict[str, Any]:
    """
    Task 3: Determine the most recent date from the instances identified
    Agent: reasoning_agent
    """
    logger.info(f"Starting task 3: Determine the most recent date from the instances ...")
    try:
        agent = ReasoningAgent()
        output_path = agent.run(query="determine the most recent date from the instances identified", session_id=None)
        
        logger.info(f"Task 3 completed: {output_path}")
        
        # Read output
        import json
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        return {
            'status': 'success',
            'task_id': 3,
            'agent': 'reasoning_agent',
            'output_path': str(output_path),
            'data': output_data,
            'error': None
        }
    except Exception as e:
        logger.error(f"Task 3 failed: {e}")
        return {
            'status': 'failed',
            'task_id': 3,
            'agent': 'reasoning_agent',
            'output_path': None,
            'data': None,
            'error': str(e)
        }



async def main() -> list:
    """Main orchestration function - sequential/mixed execution."""
    logger.info("Starting task execution")
    all_results = []

    # Execute task 1
    result_1 = await task_1()
    all_results.append(result_1)

    # Execute task 2
    result_2 = await task_2()
    all_results.append(result_2)

    # Execute task 3
    result_3 = await task_3()
    all_results.append(result_3)

    logger.info("All tasks completed")
    return all_results



if __name__ == "__main__":
    # Run the orchestration
    results = asyncio.run(main())
    
    # Print summary
    print("\n" + "="*60)
    print("ORCHESTRATION COMPLETE")
    print("="*60)
    for i, result in enumerate(results, 1):
        status = "✓ SUCCESS" if result.get('status') == 'success' else "✗ FAILED"
        print(f"Task {i}: {status}")
        if result.get('error'):
            print(f"  Error: {result['error']}")
    print("="*60)
