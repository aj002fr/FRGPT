"""
Auto-generated orchestration script for path_1.
DO NOT EDIT - Generated by OrchestratorAgent Coder
Run ID: 20251126_195428_ce417d
"""

import asyncio
import json
import logging
import time
from pathlib import Path
from typing import Dict, Any, Optional

from src.agents.market_data_agent.run import MarketDataAgent

from src.agents.orchestrator_agent.workers_db import WorkersDB

logger = logging.getLogger(__name__)

# Configuration
RUN_ID = "20251126_195428_ce417d"
DB_PATH = Path("Z:\Aastha\market_data_puller\workspace\orchestrator_results.db")


async def task_task_1() -> Dict[str, Any]:
    """
    Task task_1: Retrieve Bitcoin market data
    Agent: market_data_agent
    Tools: run_query
    """
    task_id = "task_1"
    agent_name = "market_data_agent"
    
    logger.info(f"Starting task {task_id}: Retrieve Bitcoin market data...")
    logger.info(f"Using tools: run_query")
    
    # Record task start in DB
    with WorkersDB(DB_PATH) as db:
        db.start_task(RUN_ID, task_id, agent_name)
    
    start_time = time.time()
    
    try:
        # Initialize MCP client for tool execution
        from src.mcp.discovery import get_tool
        
        # Execute tools selected by Planner 2
        tool_results = {}
        
        # Call tool: run_query
        logger.info(f"Calling tool: run_query")
        tool_func = get_tool("run_query")
        if tool_func is None:
            raise Exception(f"Tool not found: run_query")
        
        tool_params_run_query = {'template': 'by_symbol_and_date', 'params': {'symbol_pattern': '%BTC%', 'start_date': '2022-01-01', 'end_date': '2022-12-31'}, 'columns': ['close_price'], 'limit': None, 'order_by_column': 'file_date', 'order_by_direction': 'ASC'}
        result_run_query = tool_func(**tool_params_run_query)
        tool_results["run_query"] = result_run_query
        logger.info(f"Tool run_query completed")

        
        duration_ms = (time.time() - start_time) * 1000
        
        logger.info(f"Task {task_id} completed with {len(tool_results)} tool results")
        
        # Combine tool results into output data
        output_data = {
            'task_id': task_id,
            'agent': agent_name,
            'tools_used': list(tool_results.keys()),
            'data': tool_results,
            'metadata': {
                'duration_ms': duration_ms,
                'num_tools': len(tool_results)
            }
        }
        
        # Store in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='success',
                duration_ms=duration_ms,
                output_file_path=None  # Tool-based execution doesn't use file paths
            )
            db.store_task_output(
                RUN_ID,
                task_id,
                agent_name,
                output_data.get('data', []),
                output_data.get('metadata', {})
            )
        
        return {
            'status': 'success',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': None,
            'data': output_data,
            'duration_ms': duration_ms,
            'error': None
        }
        
    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        
        logger.error(f"Task {task_id} failed: {e}")
        
        # Record failure in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='failed',
                duration_ms=duration_ms,
                error=str(e)
            )
        
        return {
            'status': 'failed',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': None,
            'data': None,
            'duration_ms': duration_ms,
            'error': str(e)
        }



async def main() -> list:
    """Main orchestration function - dependency-aware execution."""
    logger.info("Starting dependency-aware execution")
    all_results = []
    task_outputs = {}  # Store outputs for dependency access

    # Task task_1 (no dependencies)
    result = await task_task_1()
    all_results.append(result)
    task_outputs["task_1"] = result

    logger.info("All tasks completed")
    return all_results



if __name__ == "__main__":
    # Run the orchestration
    results = asyncio.run(main())
    
    # Print summary
    print("\n" + "="*60)
    print(f"PATH: path_1")
    print("="*60)
    for i, result in enumerate(results, 1):
        status = "✓ SUCCESS" if result.get('status') == 'success' else "✗ FAILED"
        task_id = result.get('task_id', 'unknown')
        print(f"Task {task_id}: {status}")
        if result.get('error'):
            print(f"  Error: {result['error']}")
    print("="*60)
