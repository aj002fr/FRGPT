"""
Auto-generated orchestration script for path_1.
DO NOT EDIT - Generated by OrchestratorAgent Coder
Run ID: 20251117_155808
"""

import asyncio
import json
import logging
import time
from pathlib import Path
from typing import Dict, Any, Optional

from src.agents.market_data_agent.run import MarketDataAgent
from src.agents.reasoning_agent.run import ReasoningAgent

from src.agents.orchestrator_agent.workers_db import WorkersDB

logger = logging.getLogger(__name__)

# Configuration
RUN_ID = "20251117_155808"
DB_PATH = Path("Z:\Aastha\market_data_puller\workspace\orchestrator_results.db")


async def task_task_1() -> Dict[str, Any]:
    """
    Task task_1: Retrieve all market data related to 'Trump'
    Agent: market_data_agent
    """
    task_id = "task_1"
    agent_name = "market_data_agent"
    
    logger.info(f"Starting task {task_id}: Retrieve all market data related to 'Trump'...")
    
    # Record task start in DB
    with WorkersDB(DB_PATH) as db:
        db.start_task(RUN_ID, task_id, agent_name)
    
    start_time = time.time()
    
    try:
        # Execute agent
        agent = MarketDataAgent()
        output_path = agent.run(template="by_symbol", params={'symbol_pattern': '%'}, columns=None, limit=1000, order_by_column=None, order_by_direction="ASC")
        
        duration_ms = (time.time() - start_time) * 1000
        
        logger.info(f"Task {task_id} completed: {output_path}")
        
        # Read output from file bus
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        # Store in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='success',
                duration_ms=duration_ms,
                output_file_path=str(output_path)
            )
            db.store_task_output(
                RUN_ID,
                task_id,
                agent_name,
                output_data.get('data', []),
                output_data.get('metadata', {})
            )
        
        return {
            'status': 'success',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': str(output_path),
            'data': output_data,
            'duration_ms': duration_ms,
            'error': None
        }
        
    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        
        logger.error(f"Task {task_id} failed: {e}")
        
        # Record failure in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='failed',
                duration_ms=duration_ms,
                error=str(e)
            )
        
        return {
            'status': 'failed',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': None,
            'data': None,
            'duration_ms': duration_ms,
            'error': str(e)
        }


async def task_task_3() -> Dict[str, Any]:
    """
    Task task_3: Analyze and compare the data retrieved from market_data_agent and polymarket_agent
    Agent: reasoning_agent
    """
    task_id = "task_3"
    agent_name = "reasoning_agent"
    
    logger.info(f"Starting task {task_id}: Analyze and compare the data retrieved from market...")
    
    # Record task start in DB
    with WorkersDB(DB_PATH) as db:
        db.start_task(RUN_ID, task_id, agent_name)
    
    start_time = time.time()
    
    try:
        # Execute agent
        agent = ReasoningAgent()
        output_path = agent.run(query="analyze and compare the data retrieved from market_data_agent and polymarket_agent", session_id=None)
        
        duration_ms = (time.time() - start_time) * 1000
        
        logger.info(f"Task {task_id} completed: {output_path}")
        
        # Read output from file bus
        with open(output_path, 'r') as f:
            output_data = json.load(f)
        
        # Store in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='success',
                duration_ms=duration_ms,
                output_file_path=str(output_path)
            )
            db.store_task_output(
                RUN_ID,
                task_id,
                agent_name,
                output_data.get('data', []),
                output_data.get('metadata', {})
            )
        
        return {
            'status': 'success',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': str(output_path),
            'data': output_data,
            'duration_ms': duration_ms,
            'error': None
        }
        
    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        
        logger.error(f"Task {task_id} failed: {e}")
        
        # Record failure in DB
        with WorkersDB(DB_PATH) as db:
            db.complete_task(
                RUN_ID,
                task_id,
                status='failed',
                duration_ms=duration_ms,
                error=str(e)
            )
        
        return {
            'status': 'failed',
            'task_id': task_id,
            'agent': agent_name,
            'output_path': None,
            'data': None,
            'duration_ms': duration_ms,
            'error': str(e)
        }



async def main() -> list:
    """Main orchestration function - dependency-aware execution."""
    logger.info("Starting dependency-aware execution")
    all_results = []
    task_outputs = {}  # Store outputs for dependency access

    # Task task_1 (no dependencies)
    result = await task_task_1()
    all_results.append(result)
    task_outputs["task_1"] = result

    logger.info("All tasks completed")
    return all_results



if __name__ == "__main__":
    # Run the orchestration
    results = asyncio.run(main())
    
    # Print summary
    print("\n" + "="*60)
    print(f"PATH: path_1")
    print("="*60)
    for i, result in enumerate(results, 1):
        status = "✓ SUCCESS" if result.get('status') == 'success' else "✗ FAILED"
        task_id = result.get('task_id', 'unknown')
        print(f"Task {task_id}: {status}")
        if result.get('error'):
            print(f"  Error: {result['error']}")
    print("="*60)
